### 1. Что такое коллекция? Перечислите основные методы из интерфейса java.util.Collection.

Java Collection Framework - это иерархия интерфейсов и реализаций, которая является частью JDK и позволяет программистам пользоваться большим количеством структур для хранения набора данных. Интерфейс Collection является базовым для всех коллекций, определяя их общий функционал. Однако стоит обратить внимание, что этот интерфейс расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в так называемом улучшенном цикле for (for-each). У интерфейса Iterable определен только один метод iterator(). Таким образом, все наследники Collection (соответственно и Iterable) обязаны вернуть итератор. Итератор - это объект, который абстрагирует за единым интерфейсом доступ к элементам коллекции. К тому же итератор – это паттерн, который позволяет получить доступ к элементам любой коллекции без необходимости вникать в суть его реализации.

Главным набором методов, который важен при рассмотрении любой коллекции является набор CRUD-операций (CRUD - сокращение от слов create, read, update and delete). На уровне Collection не существует способа обновить запись в коллекции, поэтому рассмотрим остальные возможности - добавить, прочитать и удалить.

- boolean add(E e) - метод добавляет элемент в коллекцию и возвращает true если добавление выполнено успешно
- boolean addAll(Collection<? extends E> c) – метод добавляет все элементы переданной в метод коллекции в коллекцию, у которой был вызван этот метод. Метод возвращает true если коллекция, у которой был вызван метод, изменилась
- Iterator<E> iterator() – метод возвращает объект Iterator, который позволяет проходить по элементам нашей коллекции
- boolean remove(Object o) – метод удаляет объект, который мы передали в метод, и возвращает true, если удаление успешно, то есть коллекция изменилась
- boolean removeAll(Collection<?> c) – метод удаляет все элементы из коллекции, у которой был вызван этот метод, и которые также содержатся в переданной в метод коллекции, после вызова этого метода в коллекции не будет тех элементов, которые содержатся в переданной в метод коллекции
- boolean retainAll(Collection<?> c) – метод, который позволяет сохранить в коллекции только те элементы, которые содержатся в коллекции, которая была передана в метод, в результате в коллекции останутся только те элементы, которые представлены в обоих коллекциях
- int size() - метод возвращает размер коллекции, то есть фактическое количество добавленных в коллекцию элементов
- boolean isEmpty() - метод который вернет true, если коллекция пока еще не содержит элементов
- boolean contains(Object o) - метод возвращает true, если переданный в метод объект содержится в коллекции
- void clear() – удаляет все элементы из коллекции. После применения этого метода коллекция будет пустой
- Object[] toArray() - метод возвращает массив, который содержит все элементы, содержащиеся в коллекции у которой был вызван этот метод

Также в интерфейсе определены абстрактные методы equals() и hashcode(), которые не вносят никаких дополнительных условий в контракт методов Object.equals() и Object.hashcode(). Первый предназначен для сравнения коллекций друг с другом, а второй возвращает хэш-код коллекции в виде значения типа int. Важно, что для коллекций c1 и c2 если выполняется условие c1.equals(c2), то должно выполняться и условие c1.hashcode == c2.hashcode.

### 2. Назовите преимущества использования коллекций по сравнению с массивами.

Массивы не всегда удобно использовать в первую очередь потому, что массивы имеют фиксированный размер. Поэтому эту проблему в Java решают коллекции. Но дело не только в том, что коллекции обладают свойством автоматического расширения своего размера, но и то, что классы коллекций реализуют различные алгоритмы и структуры данных. Поэтому мы имеем хорошо оптимизированные структуры данных, которые описывают легкие способы работы с данными и при правильном выборе коллекции мы можем ускорить работу нашего приложения.

### 3. Какие данные могут хранить коллекции?

На вершине иерархии Java Collection Framework находятся 2 интерфейса - Collection и Map. Эти интерфейсы разделяют все коллекции, входящие во в фреймворк, на 2 части по типу хранения данных - простые последовательные наборы элементов и наборы пар "ключ-значение»".

Collection - этот интерфейс определен в JDK с версии 1.2 и описывает основные методы работы с простыми наборами элементов, которые будут общими для всех его реализаций (к примеру size(), isEmpty(), add(E e) и так далее). Интерфейс несколько был доработан с появлением generic в версии 1.5. В версии Java 8 было добавлено несколько новых методов для работы с лямбдами и Stream (например, stream(), parallelStream() и так далее).

Интерфейс Map также находится в составе JDK с версии 1.2 и предоставляет программисту базовые методы для работы с данными вида «ключ-значение». По аналогии с Collection этот интерфейс был дополнен generic в версии Java 1.5 и в версии Java 8 появились дополнительные методы для работы с лямбдами, а также методы, которые часто реализовывались в логике приложения (getOrDefault(), putIFAbsent()).

### 4. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map.

В Java коллекции организованы в иерархию интерфейсов и классов. Коллекции предоставляют разные возможности для управления данными, и выбор правильной коллекции зависит от требований к дубликатам, порядку и быстродействию. Основные интерфейсы коллекций: `Collection<E>` и `Map<K, V>`.

`Collection<E>` - это базовый интерфейс для всех коллекций, кроме `Map<K, V>`. `Collection<E>` имплементируют классы `List<E>`, `Set<E>` и `Queue<E>`. `List<E>` - упорядоченный список элементов, поддерживает дубликаты. `Set<E>` - множество уникальных элементов, не гарантирует порядок. `Queue<E>` - коллекция для обработки элементов в порядке очереди.

`Map<K, V>` - это коллекция для хранения пар "ключ-значение". `Map<K, V>` имплементируют классы `HashMap`, `LinkedHashMap` и `TreeMap`.

### 5. Назовите основные классы, которые имплементируют/реализуют интерфейсы List, Set, Map.

`Collection<E>` - это базовый интерфейс для всех коллекций, кроме `Map<K, V>`. Включает в себя:

- `List<E>` - упорядоченный список элементов, поддерживает дубликаты, включает:
  - `ArrayList` - динамический массив с быстрым доступом по индексу
  - `LinkedList` - список, основанный на связных узлах, хорош для вставки и удаления элементов
  - `Vector` (устаревший) - синхронизированная версия `ArrayList`

- `Set<E>` - множество уникальных элементов, не гарантирует порядок, включает:
  - `HashSet` - неупорядоченное множество, использует хэш-таблицу для хранения
  - `LinkedHashSet` - упорядоченное множество, сохраняет порядок вставки
  - `TreeSet` - упорядоченное множество, элементы отсортированы по возрастанию (или по компаратору)

- `Queue<E>` - коллекция для обработки элементов в порядке очереди, включает:
  - `PriorityQueue` - очередь с приоритетами, элементы упорядочены по естественному порядку или компаратору
  - `ArrayDeque` - двусторонняя очередь, поддерживает вставку/удаление с обоих концов

`Map<K, V>` - это коллекция для хранения пар "ключ-значение". Включает в себя:
- `HashMap` - неупорядоченная хэш-таблица, использует хэширование для доступа к данным
- `LinkedHashMap` - сохраняет порядок вставки
- `TreeMap`- отсортированная коллекция, элементы отсортированы по ключу
- `WeakHashMap` - карта, в которой ключи могут быть удалены сборщиком мусора, если на них нет внешних ссылок

### 6. В чём отличие ArrayList от LinkedList?

ArrayList и LinkedList - две реализации интерфейса java.util.List. Коллекция ArrayList использует несвязные списки, LinkedList - связные. Основное отличие этих коллекций - организация вставки и удаления элементов.

Связный список - базовая динамическая структура данных, состоящая из узлов, каждый из которых содержит значение и ссылку на следующий узел. Первый элемент списка - Head, последний - Tail, он ссылается на null. Связные списки похожи на массивы, однако добавление и удаление элементов из середины или из начала списка здесь проще, так как нет необходимости менять индексы всех последующих элементов.

ArrayList - самая популярная коллекция. Ее основные методы - add(), set(), remove(), get(), size().

### 7. В чём отличие HashSet от TreeSet?

HashSet и TreeSet — это реализации интерфейса Set, но они имеют несколько ключевых отличий в том, как хранят и обрабатывают элементы.

HashSet не гарантирует порядок хранения элементов, хранит элементы в произвольном порядке на основе их хэш-кодов. TreeSet хранит элементы в отсортированном порядке (по возрастанию). Если используется компаратор, сортировка может быть кастомизирована.

HashSet реализован на основе хэш-таблицы. TreeSet реализован на основе красно-чёрного дерева (самобалансирующегося двоичного дерева поиска), что позволяет поддерживать отсортированный порядок элементов.

У элементов HashSet следует корректно переопределять методы hashCode() и equals(), чтобы обеспечивать правильную работу хэш-таблицы.
У элементов TreeSet нужно реализовывать интерфейс Comparable или передаваться в TreeSet с компаратором, иначе будет выброшено исключение ClassCastException, так как элементы должны сравниваться между собой для сортировки.

### 8. В чём отличие Set от Map?

Set хранит только уникальные элементы, каждый элемент в Set считается отдельной сущностью. Map хранит пары ключ-значение, каждый ключ уникален, но значения могут повторяться.

Интерфейс Set наследует интерфейс Collection. Интерфейс Map не наследует Collection, поскольку это отдельная структура данных.

### 9. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?

Сортировка данных - это упорядочивание данных. Сортировка может быть двух видов: по возрастанию и по убыванию.

В Java большинство коллекций поддерживает статический метод Collections.sort, который позволяет отсортировать коллекцию. Java производит сортировку по возрастанию. Внутри метода sort осуществляется сортировка методом слияния. Чтобы использовать алгоритм слияния, сортируемый тип данных должен поддерживать интерфейс java.util.Comparable. Все встроенные типы данных поддерживают этот интерфейс. Интерфейс Comparable имеет единственный метод compareTo(T t). Этот метод возвращает меньше нуля, ноль, больше нуля. Меньше нуля - если входящее значение больше, чем текущий объект. Ноль - если значения равны. Больше нуля - если текущее значение больше, чем входящее. Текущее значение - это объект, у которого вызван метод compareTo.

### 10. Чем отличается Comparable от Comparator?

Через интерфейс java.lang.Comparable мы можем задать только один порядок сортировки. Чтобы сделать другой порядок, в Java есть интерфейс, который не привязан к модели данных. Это интерфейс java.util.Comparator. В нем есть метод int compare(T first, T second), который принимает сразу два параметра. Для всех встроенных типов Integer, String и так далее в Java есть готовые классы, реализующие этот интерфейс.

Comparable — это интерфейс, входящий в пакет java.lang и используемый для сортировки классов на основе их естественного порядка. Интерфейс Comparable должен быть реализован в классе, который будет использоваться для сортировки. Comparator - это интерфейс, входящий в пакет java.util, который также используется для сортировки коллекций в Java. В отличие от Comparable, интерфейс Comparator не обязательно должен быть реализован в исходном классе, его можно реализовать и в отдельном классе. Используя Comparator, можно сортировать список на основе различных атрибутов в соответствии с нашими требованиями.

### 11. Что такое сортировка по принципу Natural Order?

Натуральное упорядочивание - это естественная сортировка, она реализована в методе compareTo() интерфейса Comparable. Natural Ordering уже присутствует в Java. Например, Java знает, что строки чаще всего сортируют по алфавиту, а числа — по возрастанию их значения. Поэтому если вызвать на списке чисел или строк метод sort(), так они и будут отсортированы. При сортировке элементов типа char используется лексикографическое упорядочение.

### 12. Что такое equals и hashcode?

`equals()` и `hashCode()` - это два ключевых метода в Java, которые играют важную роль в сравнении объектов и работе с коллекциями. Оба метода наследуются от класса `Object` и могут быть переопределены в классах, чтобы обеспечить правильное поведение для пользовательских объектов.

Метод `equals()` используется для сравнения двух объектов на логическое равенство. По умолчанию, метод `equals()` из класса `Object` сравнивает объекты на ссылочное равенство, то есть возвращает `true`, если обе переменные указывают на один и тот же объект в памяти. Однако часто требуется сравнивать объекты по содержимому, например, по значению их полей, для чего нужно переопределить метод `equals()`.

Пример переопределения `equals()`:

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;           // Сравнение по ссылке
    if (obj == null || getClass() != obj.getClass()) return false;  // Проверка типа
    User user = (User) obj;
    return name.equals(user.name) && age == user.age;  // Сравнение полей
}
```

Пример работы метода:

```java
User user1 = new User("Ivan", 25);
User user2 = new User("Ivan", 25);

System.out.println(user1.equals(user2));  // true, если метод переопределён корректно
```

Метод `hashCode()` возвращает целочисленное значение (хеш-код), представляющее собой "уникальный" идентификатор объекта. Этот метод используется для оптимизации поиска объектов, например, в таких коллекциях, как `HashMap`, `HashSet`, и других, основанных на хешировании.

По контракту, если два объекта равны по `equals()`, они должны иметь одинаковый `hashCode()`. Это важно для корректной работы таких коллекций, как `HashMap` и `HashSet`.

Пример переопределения `hashCode()`:
```java
@Override
public int hashCode() {
    return Objects.hash(name, age);  // Генерация хеша на основе полей
}
```

Пример работы метода:
```java
User user1 = new User("Ivan", 25);
User user2 = new User("Ivan", 25);

System.out.println(user1.hashCode() == user2.hashCode());  // true, если объекты равны по equals()
```

Контракт `equals()` и `hashCode()`:
- если два объекта равны по методу `equals()`, они должны возвращать одинаковые хеш-коды,
- если два объекта не равны по методу `equals()`, то их хеш-коды могут быть как одинаковыми, так и разными,
- переопределяя `equals()`, необходимо переопределить и `hashCode()`

Пример работы с коллекциями. При добавлении объектов в коллекции, основанные на хешах (например, `HashSet` или `HashMap`), используется метод `hashCode()` для быстрой идентификации места хранения объекта. Если два объекта имеют одинаковый хеш-код, коллекция дополнительно использует метод `equals()` для проверки, равны ли объекты логически. Таким образом, `equals()`** определяет, равны ли два объекта, а`hashCode()`** используется для оптимизации работы хеш-коллекций.

### 13. Какие есть способы перебора всех элементов List?

В Java есть несколько способов перебора всех элементов коллекции `List`. Вот основные из них:

- с использованием цикла `for-each` (расширенный `for`)

```java
for (String item : list) {
System.out.println(item);
}
```

- с использованием `Iterator`, который позволяет перебирать элементы коллекции и безопасно удалять их во время перебора,

```java
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

или `ListIterator` (специализированный итератор для списков, который позволяет перебирать элементы как вперёд, так и назад, а также изменять элементы во время итерации)

```java
ListIterator<String> listIterator = list.listIterator();
while (listIterator.hasNext()) {
    System.out.println(listIterator.next());
}
```

- с использованием метода `forEach()` (в Java 8 и выше), этот метод позволяет перебрать элементы с использованием лямбда-выражений

```java
list.forEach(item -> System.out.println(item));
```

или с использованием ссылки на метод:

```java
list.forEach(System.out::println);
```

- с помощью `Stream API` (начина с Java 8) можно перебирать элементы и выполнять различные операции над ними

```java
list.stream().forEach(System.out::println);
```

или можно использовать параллельные потоки для более производительного перебора

```java
list.parallelStream().forEach(System.out::println);
```

- с использованием цикла `while`

```java
int i = 0;
while (i < list.size()) {
    System.out.println(list.get(i));
    i++;
}
```

Для простого перебора лучше всего подходят циклы `for-each`, `for`, или метод `forEach()`. Для параллельных операций или сложных преобразований удобно использовать `Stream API`. Для безопасного удаления или изменения элементов во время перебора следует использовать `Iterator` или `ListIterator`.

### 14. Расскажите об основных методах Map.

Среди методов интерфейса Map можно выделить следующие:

- void clear() - очищает коллекцию

- boolean containsKey(Object k) - возвращает true, если коллекция содержит ключ k

- boolean containsValue(Object v) - возвращает true, если коллекция содержит значение v

- Set<Map.Entry<K, V>> entrySet() - возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry

- equals(Object obj) - возвращает true, если коллекция идентична коллекции, передаваемой через параметр obj

- boolean isEmpty - возвращает true, если коллекция пуста

- V get(Object k) - возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение null

- V getOrDefault(Object k, V defaultValue) - возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение defaultVlue

- V put(K k, V v): помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект с подобным ключом, то он перезаписывается. После добавления возвращает предыдущее значение для ключа k, если он уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение null

- V putIfAbsent(K k, V v) - помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет элемента с подобным ключом.

- Set<K> keySet() - возвращает набор всех ключей отображения

- Collection<V> values() - возвращает набор всех значений отображения

- void putAll(Map<? extends K, ? extends V> map) - добавляет в коллекцию все объекты из отображения map

- V remove(Object k) - удаляет объект с ключом k

- int size() - возвращает количество элементов коллекции

Чтобы положить объект в коллекцию, используется метод put, а чтобы получить по ключу - метод get. Реализация интерфейса Map также позволяет получить наборы как ключей, так и значений. А метод entrySet() возвращает набор всех элементов в виде объектов Map.Entry<K, V>.

### 15. Расскажите, какие классы реализовывают интерфейс Map?

Базовым классом для всех отображений является абстрактный класс AbstractMap, который реализует большую часть методов интерфейса Map. Наиболее распространенным классом отображений является HashMap, который реализует интерфейс Map и наследуется от класса AbstractMap. Интерфейс SortedMap расширяет Map и создает отображение, в котором все элементы отсортированы в порядке возрастания их ключей. Интерфейс NavigableMap расширяет интерфейс SortedMap и обеспечивает возможность получения элементов отображения относительно других элементов. Класс TreeMap<K, V> представляет отображение в виде дерева. Он наследуется от класса AbstractMap и реализует интерфейс NavigableMap, а следовательно, также и интерфейс SortedMap. Поэтому в отличие от коллекции HashMap в TreeMap все объекты автоматически сортируются по возрастанию их ключей.

### 16. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?

Метод keySet() возвращает коллекцию java.util.Set, состоящую только из ключей (ассоциированное с этим ключом значение получаем через метод get).

Метод entrySet() вернет коллекцию java.util.Set, состоящую из объекта Map.Entry, которая сразу содержит и ключ и значение.

Обобщенный интерфейс Map.Entry<K, V> представляет объект с ключом типа K и значением типа V и определяет следующие методы:

- boolean equals(Object obj): возвращает true, если объект obj, представляющий интерфейс Map.Entry, идентичен текущему

- K getKey(): возвращает ключ объекта отображения

- V getValue(): возвращает значение объекта отображения

- V setValue(V v): устанавливает для текущего объекта значение v

- int hashCode(): возвращает хеш-код данного объекта

### 17. Что будет если вызвать метод map.put несколько раз с одинаковым ключом?

Будет обновление пары "ключ-значение" со старым ключем и (старым или новым) значением.

### 18. Как реализован цикл for-each?

Цикл for-each внутри использует механизм итератора.

Интерфейс Iterator<E> определен в пакете java.util и имеет три основных метода:
- boolean hasNext() - проверяет на наличие следующего элемента в списке
- T next() - возвращает элемент из коллекции и переводит указатель на следующий элемент
- void remove() - удаляет элемент из коллекции и переводит указатель назад

Указатель - это механизм, позволяющий извлечь одиночный элемент из коллекции. Например, для массива указатель - это индекс элемента.

### 19. В чем разница между Iterator и Iterable?

В пакете java.lang есть интерфейс Iterable<T>, в пакете java.util - интерфейс Iterator<E>.

Реализующие интерфейс Iterable<T> классы (например, ArrayList, HashSet и TreeSet) могут использовать цикл for-each.

Iterator<E> - это интерфейс Java Collections Framework, это итератор по коллекциям. Итератор заменяет Enumeration в Java Collections Framework, предоставляя некоторые улучшения, например, возможность удаления элементов коллекции во время итерации.

### 20. Как происходит удаление элементов из ArrayList?

ArrayList основан на динамическом массиве. Когда удаляется элемент по индексу или по значению, выполняется смещение всех последующих элементов на одну позицию влево, чтобы заполнить образовавшийся "пробел". Это смещение элементов - самая затратная операция при удалении, и время её выполнения зависит от количества элементов, которые нужно переместить. Методы:

- метод remove(int index) удаляет элемент по его индексу, сдвигает все элементы, находящиеся после удалённого, влево
- метод remove(Object o) удаляет первое вхождение указанного элемента из списка, если оно существует
- метод clear() удаляет все элементы
- метод removeIf(Predicate<? super E> filter) удаляет все элементы, которые удовлетворяют переданному условию (предикату)
- метод subList().clear() удаляет элементы в указанном диапазоне индексов, используя метод subList() и его метод clear()

### 21. Как происходит удаление элементов из LinkedList?

LinkedList реализует интерфейсы List и Deque, что позволяет удалять элементы как из начала, так и из конца списка, а также по индексу или значению. LinkedList основан на двусвязном списке (двунаправленные узлы), где каждый элемент (узел) имеет ссылки на предыдущий и следующий элементы. Когда удаляется элемент, список просто меняет ссылки. При удалении по значению или индексу сначала ищется нужный элемент, затем обновляются ссылки так, чтобы предыдущий элемент указывал на следующий после удаляемого. При удалении первого или последнего элемента просто меняется ссылка на первый или последний элемент списка.

- методы removeFirst() и pollFirst() удаляют первый элемент из начала списка, removeFirst(), первый сгенерирует исключение при пустом листе, второй - вернет null
- методы removeLast() и pollLast() удаляют последний элемент из конца списка, первый сгенерирует исключение при пустом листе, второй - вернет null
- метод remove(Object o) удаляет первое вхождение указанного элемента
- метод remove(int index) удаляет элемент по индексу
- метод clear() очищает список (удаляет все элементы)

### 22. Что такое автоупаковка и распаковка? Зачем они нужны?

Примитивные типы не являются ссылочными типами (объектами), поэтому если нам требуется объект примитивного типа, его значение должно быть упаковано в соответствующий класс-обёртку. Например, int в Integer или long в Long. Начиная с Java 5 такие преобразования выполняются компилятором автоматически и называются автоупаковкой и распаковкой.

Распаковка и упаковка касается только единичных элементов. Например, нельзя упаковать/распаковать таким образом массив int в лист Integer или распаковать лист в массив. Значения примитивных типов (int, long, char и так далее) - это чистые данные. А соответствующие им ссылочные типы Integer, Long, Character и так далее - это обёртки для этих чистых данных.

Автоупаковка происходит в следующих случаях:

- если значение примитивного типа присваивается типу соответствующего класса-обёртки
- если значение примитивного типа передаётся в параметр метода, который предусматривает соответствующий класс-обёртку

Распаковка происходит в следующих случаях:

- если объект класса-обёртки присваивается переменной соответствующего примитивного типа
- если объект класса-обёртки передаётся в параметр метода, который предусматривает примитивный тип
- в выражениях с использованием различных операторов типа +, -, *, /, % и так далее, если один или оба операнда являются объектами классов-обёрток

### 23. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?

Появление классов-обёрток обусловлено тем, что Java - объектно-ориентированный язык, и все сущности в идеале должны быть объектами. Но отказавшись от примитивных типов, упала бы производительность, поэтому к существующим примитивным типам добавили соответствующие классы-обертки, тем самым обеспечив гибкость работы с примитивными значениями. Упаковка и распаковка значений будут в какой-то степени влиять на производительность программы. Для очень трудоёмких вычислений, где производительность критически важна, следует использовать примитивные типы.

Классы-обертки являются неизменяемыми, поэтому упакованное значение невозможно изменить. Следующий код будет приводить в постоянному пересозданию новых объектов и чрезмерному расходу памяти:

```java
Integer sum = 0;
for (int i = 128; i < 300; i++) {
sum += i;
}
        System.out.println(sum);
```
При перезаписи переменной sum каждый раз будет создаваться новый объект в памяти. Исключением являются только кэшированные значения из пула Integer от -128 до 127 включительно. Эти значения будут браться из него (переменная sum будет ссылаться на соответствующее значение в пуле Integer).

### 24. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.

При работе с примитивными типами повышается производительность, так как на упаковку значения в обёртку уходит дополнительное время. Примитивные типы занимают меньше места в памяти. Если в программе работа идет с объектами, а не со значениями, то работать с примитивными типами будет нельзя, понадобится упаковка.

Обёртки - это такие же классы со своими методами, как и любые остальные. Поэтому работа со значением в виде объекта даёт преимущества в виде возможности применения методов этих классов. Например, для Integer это parseInt(), valueOf(), compareTo() и так далее.

### 25. Что такое очередь? Расскажите принцип работы и для чего она используется.

Структура данных, которая в программировании называется очередью, представляет из себя хранилище однотипных элементов, в котором первым будет извлекаться тот элемент, который был туда и вставлен первым. Такой способ организации хранения данных называется FIFO, по первым буквам фразы, описывающей этот способ хранения - First-In-First-Out). Очередь работает по тому же принципу, как и любая очередь в реальной жизни - например очередь за билетами в кино (человек, который первым встал в очередь первым дойдет до кассы и купит билет). Следовательно, тот, кто станет в очередь последним - и купит билет последним.

### 26. Расскажите про интерфейсы Queue, Deque и их иерархию.

Интерфейс Queue является прямым наследником Collection, а тот интерфейс в свою очередь наследует интерфейс Iterable. Следовательно, помимо тех методов, которые определены в Queue, в нем также доступны все методы вышестоящих интерфейсов, которые мы рассматривали ранее. Интерфейс Deque наследует Queue и расширяет его методы.

Методы интерфейса Queue:

- метод add() добавляет элемент в конец очереди (за исключением PriorityQueue, там элемент добавляется согласно своему приоритету)
- методы remove() и poll() позволяют вернуть и удалить верхний (первый) элемент из очереди, первый при пустой очереди выбрасывает исключение NoSuchElementException, второй выдает null
- метод offer() предпринимает попытку вставки элемента в конец очереди, если в качестве реализации будет использована та, которая может иметь ограниченный размер, то при переполнении очереди метод offer() добавить элемент не сможет
- методы peek() и element() позволяют вернуть элемент из очереди без его удаления, если метод element() вызывать на пустой очереди, то будет сгенерировано исключение NoSuchElementException, в случае peek() выведется null

### 27. В чем отличие метода poll() от remove()?

Методы remove() и poll() позволяют вернуть и удалить верхний (первый) элемент из очереди, первый при пустой очереди выбрасывает исключение NoSuchElementException, второй выдает null.

### 28. В чем отличие метода element() от peek()?

Методы peek() и element() позволяют вернуть элемент из очереди без его удаления, если метод element() вызывать на пустой очереди, то будет сгенерировано исключение NoSuchElementException, в случае peek() выведется null

### 29. В чем отличие метода element() от poll()?

Метод element() позволяет вернуть элемент из очереди без его удаления, тогда как метод poll() позволяет вернуть и удалить верхний (первый) элемент из очереди. При пустой очереди element() генерирует исключение NoSuchElementException, а poll() выдает null.

### 30. Перечислите наиболее часто используемые реализации интерфейса Queue.

LinkedList , ArrayBlockingQueue и PriorityQueue - наиболее часто используемые реализации интерфейса Queue.

### 31. Что такое ограниченные и неограниченные очереди?

Очереди, доступные в пакете java.util, являются неограниченными очередями ((Unbounded Queue) ).  Например, класс LinkedList, который реализует интерфейс Queue, является примером неограниченной очереди. В неограниченной очереди методы для добавления элементов (add() и offer()) всегда успешно добавляют элемент, если не исчерпана память. 

Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями (Bounded Queue).  Ограниченная очередь может вместить только определенное количество элементов. Класс ArrayBlockingQueue, реализующий интерфейс BlockingQueue, является примером ограниченной очереди. Если очередь полная, то попытка добавления элемента через add() вызовет исключение IllegalStateException, а метод offer() вернет false. Методы добавления могут блокировать поток, если очередь полная, при использовании методов типа put() (в BlockingQueue).

### 32. Что такой односторонние и двусторонние очереди?

Односторонняя очередь позволяет поместить элементы в один конец очереди, а извлекать их – из другого. Двусторонняя очередь поддерживает удаление и добавление элементов с обоих концов очереди.

### 33. В чём отличие Deque от Queue?

Deque наследуется от Queue, Queue - односторонняя очередь, Deque - двусторонняя. 

Queue устроена по типу FIFO (First-In-First-Out - первый пришел, первый вышел), Deque - по типам FIFO и LIFO (Last In First Out - последний пришел, первый вышел - стек).

В очередь Deque элементы можно добавлять, удалять и извлекать с обоих ее сторон.

### 34. В чём отличие методов removeLast() и pollLast()?

Методы removeLast() и pollLast() позволяют удалить последний элемент из очереди с его возвратом. Первый сгенерирует исключение при пустой очереди, второй – вернет null.

### 35. Назовите самую распространенную реализацию Deque.

Наиболее часто используемой реализацией интерфейса Deque является класс LinkedList.

### 36. В чем отличия между Collection и Collections?

Collection - это основной интерфейс в Java Collections Framework (JCF), от которого наследуются другие интерфейсы, такие как List, Set и Queue. Определяет общие методы, которые должны быть реализованы всеми коллекциями в Java, такие как add(), remove(), size(), clear() и другие.

Collections - это вспомогательный класс (utility class) в JCF, содержащий статические методы для работы с коллекциями. Collections предоставляет методы для работы с объектами, реализующими интерфейс Collection и его наследников. Примеры методов: sort(), binarySearch(), reverse(), synchronizedList(), unmodifiableList() и другие. Таким образом, Collection - это базовый интерфейс для всех коллекций, а Collections - это утилитарный класс, который помогает работать с ними.