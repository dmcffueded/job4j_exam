### 1. Что такое ООП? Что такое класс? Что такое объект?

Объектно-ориентированное программирование (ООП) - это парадигма (методология) программирования, в которой приложения состоят из взаимодействующих между собой объектов. Парадигма в программировании означает некий набор правил по написанию и оформлению кода, общепринятый в сообществе разработчиков.

Каждая компьютерная программа состоит из кода и данных. Программа может быть организована вокруг своего кода, либо вокруг своих данных. В первом случае процесс выполнения программы можно охарактеризовать как "что происходит", а во втором как "на что оказывается влияние". Отсюда вытекают две основных парадигмы создания программ: ориентация на процессы или на объекты.

Иначе, ООП - это парадигма программирования, в которой данные и поведение объединяются в объекты. Класс - это шаблон или чертеж для создания объектов. Он описывает, какие свойства (переменные) и методы (функции) будут у объектов. Объект - это экземпляр класса. Он создается на основе класса и обладает свойствами и поведением, которые определены в классе.

Пример: если класс - это чертеж дома, то объект - это конкретный дом, построенный по этому чертежу.

### 2. Расскажите про базовые концепции ООП.

Основные принципы ООП: инкапсуляция, наследование, полиморфизм и абстракция.

Инкапсуляция - это механизм скрытия внутренней реализации объекта и предоставление доступа к его данным только через методы (функции). Инкапсуляция помогает защитить данные от неправильного использования и упрощает работу с объектом. Пример: переменные класса часто делаются приватными, а доступ к ним осуществляется через публичные методы (геттеры и сеттеры).

Наследование - это возможность создавать новые классы на основе существующих. Новый класс (наследник) наследует свойства и методы базового класса (родителя), но также может иметь свои собственные. Пример: класс "Кошка" может наследоваться от класса "Животное", получая общие свойства и поведение всех животных.

Полиморфизм - это способность одного и того же метода работать с объектами разных типов. Полиморфизм позволяет обрабатывать объекты как экземпляры базового класса, даже если они на самом деле являются экземплярами его наследников. Пример: метод `draw()` может вызываться для объектов классов Круг, Квадрат, Треугольник, но его реализация для каждого класса будет своей.

Абстракция - это процесс выделения общих характеристик объектов и их представление в виде абстрактных понятий, без указания деталей реализации. Абстракция помогает работать с объектами на более высоком уровне, упрощая взаимодействие с ними. Пример: класс "Транспортное средство" может быть абстрактным, описывающим общие свойства всех транспортных средств (скорость, вес), но конкретная реализация (автомобиль, велосипед) будет определяться в классах-наследниках.

Эти концепции помогают строить гибкие, расширяемые и понятные программы.

### 3. Укажите, из каких элементов состоит класс. Расскажите о каждом из них.

Класс в Java состоит из восьми основных элементов: имя класса, модификатор доступа, поля (переменные класса), конструкторы, методы, модификаторы методов и полей, блоки инициализации, вложенные классы. Эти элементы в совокупности образуют структуру класса в Java, которая определяет его поведение и данные.

- Имя класса - это название класса, которое должно соответствовать правилам именования Java (начинается с заглавной буквы, если состоит из нескольких слов - используется CamelCase). Имя класса используется для его идентификации в программе.

   ```java
   public class MyClass { ... }
   ```

- Модификатор доступа - это ключевое слово, которое определяет область видимости и доступ к классу. В Java используются следующие модификаторы доступа: `public` (класс доступен из любого другого класса; без модификатора (то есть `default`, иначе - класс доступен только в пределах пакета).

   ```java
   public class MyClass { ... }
   ```

- Поля (переменные класса) - это переменные, которые хранят состояние объекта. Поля могут быть различного типа и иметь модификаторы доступа (`private`, `public`, `protected`), которые определяют доступ к этим переменным.

   ```java
   private int age;
   public String name;
   ```

- Конструктор - это специальный метод, который вызывается при создании объекта класса. Он используется для инициализации полей объекта. Конструкторы могут быть с параметрами и без параметров.

   ```java
   public MyClass(int age, String name) {
       this.age = age;
       this.name = name;
   }
   ```

- Методы описывают поведение класса, то есть то, что объекты этого класса могут делать. Методы могут возвращать значения или быть типом `void` (ничего не возвращают). Методы могут иметь параметры для передачи данных.

   ```java
   public void printInfo() {
       System.out.println(name + " is " + age + " years old.");
   }
   ```

- Модификаторы методов и полей - эти ключевые слова используются для управления доступом к полям и методам.

    - `private` - доступ только внутри этого класса
    - `public` - доступ из любого другого класса
    - `protected` - доступ в пределах пакета и подклассов
    - `static` - метод или поле принадлежит классу, а не экземпляру (объекту)
    - `final` - значение не может быть изменено или метод не может быть переопределён

   ```java
   private final int maxAge = 100;
   public static int getMaxAge() { return maxAge; }
   ```

- Блоки инициализации - это блоки кода, которые выполняются при создании объекта или при загрузке класса (для статических блоков). Обычно используются для инициализации сложных данных.

  ```java
  {
      System.out.println("This is an instance block.");
  }
   
  static {
      System.out.println("This is a static block.");
  }
  ```

- Вложенные классы - классы, содержащиеся в другом (внешнем) классе. Вложенные классы могут быть статическими или нестатическими.

  ```java
  public class OuterClass {
      public class InnerClass { ... }
  }
  ```

### 4. Что такое конструктор?

Конструктор — это специальный метод в Java, который используется для создания и инициализации объектов класса. Конструктор вызывается автоматически при создании нового экземпляра класса с помощью ключевого слова `new`.

Особенности конструктора:

- Имя конструктора совпадает с именем класса
- Не имеет возвращаемого типа** (даже `void`)
- Конструкторы могут быть с параметрами и без параметров
- Если конструктор не определён, Java автоматически создаёт конструктор по умолчанию без параметров

Пример конструктора:

```java
public class Person {
    private String name;
    private int age;

    // Конструктор с параметрами
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Конструктор без параметров
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }
}
```

В этом примере при создании объекта `Person` конструктор будет инициализировать его поля. Конструктор без параметров присваивает значения по умолчанию, а конструктор с параметрами позволяет задать значения при создании объекта.

### 5. Можно ли наследовать конструктор? Расскажите про вызов конструктора родителя методом super().

Конструкторы не наследуются в Java, но они могут быть вызваны в подклассах с помощью ключевого слова `super()`. Вызов конструктора родительского класса через `super()` используется для инициализации полей и поведения, унаследованных от родителя.

Работает `super()` следующим образом:

- Вызов `super()` должен быть первой строкой в конструкторе подкласса
- Если в подклассе не указано явно `super()`, компилятор автоматически вставит вызов конструктора по умолчанию родительского класса (без параметров)
- Если в родительском классе нет конструктора без параметров, то его необходимо явно вызвать через `super(аргументы)`

Пример:

```java
class Animal {
    String name;

    // Конструктор родителя
    public Animal(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    int age;

    // Конструктор дочернего класса
    public Dog(String name, int age) {
        super(name); // Вызов конструктора родителя
        this.age = age;
    }
}
```

В этом примере в классе `Dog` вызывается конструктор класса `Animal` с помощью `super(name)`. Это позволяет инициализировать поле `name`, которое принадлежит родителю, а затем уже в конструкторе дочернего класса инициализируется поле `age`.

Ключевое слово `super()` может использоваться не только в конструкторах, но и для вызова методов или доступа к полям родителя, если они не скрыты в дочернем классе. Если родительский класс имеет несколько конструкторов, можно вызывать любой из них, передавая нужные параметры.

### 6. Что такое перегрузка конструктора?

Перегрузка конструктора (constructor overloading) - это механизм в Java, который позволяет классу иметь несколько конструкторов с одними и теми же именами, но разными наборами параметров. Это удобно, если при создании объекта нужно предусмотреть разные способы его инициализации. Конструкторы должны различаться по количеству параметров и (или) по их типам. Перегрузка дает возможность создавать объекты с различными наборами исходных данных. Перегрузка конструкторов позволяет разработчику предоставлять различные варианты инициализации объектов в зависимости от доступных данных.

Пример перегрузки конструктора:

```java
class Person {
    String name;
    int age;

    // Конструктор без параметров (по умолчанию)
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }

    // Конструктор с одним параметром
    public Person(String name) {
        this.name = name;
        this.age = 0;
    }

    // Конструктор с двумя параметрами
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

Использование перегруженного конструктора при создании объекта:

```java
Person person1 = new Person();               // Вызов конструктора по умолчанию
Person person2 = new Person("John");         // Вызов конструктора с одним параметром
Person person3 = new Person("John", 25);     // Вызов конструктора с двумя параметрами
```

В этом примере у класса `Person` три конструктора: первый - без параметров (инициализирует поля значениями по умолчанию), второй - с параметром `name` (инициализирует только имя), третий - с параметрами `name` и `age` (инициализирует оба поля).

### 7. Что такое статический метод?

Статический метод (static method) - это метод, который принадлежит самому классу, а не его экземплярам (объектам). В Java статические методы обозначаются ключевым словом static. Они могут быть вызваны напрямую через имя класса без создания его объекта. Статические методы могут напрямую обращаться только к статическим полям и другим статическим методам того же класса. Статические методы не имеют доступа к нестатическим (экземплярным) полям и методам класса, так как они не связаны с конкретным объектом. Статические методы вызываются через имя класса. Статические методы и переменные загружаются в память один раз, и это помогает экономить ресурсы.

Пример статического метода:

```java
class Calculator {

    // Статический метод для сложения
    public static int add(int a, int b) {
        return a + b;
    }

    // Нестатический метод
    public int multiply(int a, int b) {
        return a * b;
    }
}

public class Main {
public static void main(String[] args) {
// Вызов статического метода без создания объекта
int sum = Calculator.add(5, 3);
System.out.println("Сумма: " + sum);

        // Для вызова нестатического метода нужно создать объект
        Calculator calculator = new Calculator();
        int product = calculator.multiply(5, 3);
        System.out.println("Произведение: " + product);
    }
}
```

### 8. Что такое нестатический метод?

Нестатический метод (или метод экземпляра) - это метод, который принадлежит объекту (экземпляру) класса, а не самому классу. Чтобы использовать нестатический метод, нужно сначала создать объект этого класса. Нестатические методы могут обращаться как к нестатическим, так и к статическим полям и методам класса. Нестатические методы обеспечивают взаимодействие с полями и методами конкретного объекта и часто используются для работы с индивидуальными данными экземпляров.

Статические поля относятся к самому классу и разделяются всеми объектами, а нестатические — к конкретному объекту. Статическое поле остаётся общим для всех объектов, и его изменения видны во всех экземплярах класса.

Пример нестатического метода:

```java
class Calculator {

    // Нестатический метод для сложения
    public int add(int a, int b) {
        return a + b;
    }

    // Нестатический метод для умножения
    public int multiply(int a, int b) {
        return a * b;
    }
}

public class Main {
    public static void main(String[] args) {
        // Создание объекта класса Calculator
        Calculator calculator = new Calculator();

        // Вызов нестатических методов через объект
        int sum = calculator.add(5, 3);
        int product = calculator.multiply(5, 3);

        System.out.println("Сумма: " + sum);
        System.out.println("Произведение: " + product);
    }
}
```
Пример того, как нестатический метод обращается к статическому полю:

```java
class Example {
    // Статическое поле
    private static int staticCounter = 0;

    // Нестатическое поле
    private int instanceCounter = 0;

    // Нестатический метод
    public void increment() {
        // Обращение к статическому полю
        staticCounter++;
        // Обращение к нестатическому полю
        instanceCounter++;

        System.out.println("Static counter: " + staticCounter);
        System.out.println("Instance counter: " + instanceCounter);
    }
}

public class Main {
    public static void main(String[] args) {
        Example example1 = new Example();
        Example example2 = new Example();

        // Вызов нестатического метода у первого объекта
        example1.increment(); // Static counter: 1, Instance counter: 1

        // Вызов нестатического метода у второго объекта
        example2.increment(); // Static counter: 2, Instance counter: 1

        // Вызов у первого объекта
        example1.increment(); // Static counter: 3, Instance counter: 2
    }
}
```

Здесь статическое поле `staticCounter` - общее для всех объектов класса. Когда любой объект изменяет это поле, оно меняется для всех объектов. Нестатическое поле `instanceCounter` - индивидуальное для каждого объекта. Каждый объект хранит своё значение этого поля. В методе `increment` есть обращение и к статическому полю, и к нестатическому. Статическое поле изменяется независимо от того, какой объект вызывает метод, а нестатическое меняется только для того объекта, который вызвал метод. В итоге, статическое поле остаётся общим для всех объектов, и его изменения видны во всех экземплярах класса.

### 9. Для чего используется ключевое слово this?

Ключевое слово `this` в Java используется для ссылки на текущий экземпляр (объект) класса. Оно помогает явно указывать на текущий объект и избегать путаницы между полями и параметрами метода или конструктора, а также для вызова других конструкторов или методов внутри класса.

Примеры использования ключевого слова:

- Различение полей объекта и параметров метода. Если параметры метода или конструктора совпадают с именами полей класса, `this` помогает различить их.

   ```java
   class Person {
       private String name;

       public Person(String name) {
           this.name = name; // Здесь this.name — это поле класса, а name — параметр конструктора
       }
   }
   ```

- Вызов другого конструктора из конструктора. В этом случае `this` можно использовать для вызова одного конструктора из другого в том же классе.

   ```java
   class Person {
       private String name;
       private int age;

       public Person(String name) {
           this(name, 18); // Вызов другого конструктора с двумя параметрами
       }

       public Person(String name, int age) {
           this.name = name;
           this.age = age;
       }
   }
   ```

- Передача текущего объекта как аргумента. Иногда требуется передать текущий объект в метод или конструктор другого класса.

   ```java
   class Car {
       public void display(Car car) {
           System.out.println("This is a car: " + car);
       }

       public void show() {
           display(this); // Передача текущего объекта
       }
   }
   ```

- Возврат текущего объекта. Ключевое слово `this` может быть использовано для возврата текущего объекта из метода.

   Пример:
   ```java
   class Car {
       public Car getInstance() {
           return this;
       }
   }
   ```
  
### 10. Какой класс является базовым родительским классом для всех классов?

В Java базовым родительским классом для всех классов является класс `Object`.

Все классы в Java неявно наследуются от класса `Object`. Это означает, что любой создаваемый программистом класс автоматически наследует методы и свойства класса `Object`.

Класс `Object` предоставляет несколько важных методов, которые могут быть переопределены в наследуемых классах:

- `toString()` возвращает строковое представление объекта
- `equals(Object obj)` сравнивает два объекта на равенство
- `hashCode()` возвращает хеш-код объекта
- `getClass()` возвращает объект класса `Class`, который представляет класс объекта
- `clone()` создает и возвращает копию объекта (если класс реализует интерфейс `Cloneable`)
- `finalize()` выполняет очистку перед сборкой мусора (редко используется)

Пример:

```java
public class MyClass {
    @Override
    public String toString() {
        return "This is MyClass";
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        System.out.println(obj.toString()); // Вывод: This is MyClass
    }
}
```

В этом примере метод `toString()` переопределяется в `MyClass`, чтобы предоставить специфичное для этого класса представление объекта, а базовая реализация предоставлена классом `Object`.

### 11. Что такое наследование? Приведите примеры из реальной жизни.

Наследование - это возможность создавать новые классы на основе существующих. Новый класс (наследник) наследует свойства и методы базового класса (родителя), но также может иметь свои собственные. Наследование упрощает организацию кода и поддерживает концепцию повторного использования. Пример: классы "Птица" и "Рыба" могут наследоваться от класса "Животное", получая общие свойства и поведение всех животных. В этом случае общие свойства - возраст, масса, а общие методы - двигаться, есть. В частности, птица летает, а рыба - плавает.

Пример:

```java
// Родительский класс
class Vehicle {
    int speed;
    int wheels;

    public void drive() {
        System.out.println("The vehicle is moving.");
    }
}

// Наследник
class Car extends Vehicle {
    String bodyType;

    public void honk() {
        System.out.println("The car is honking.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.speed = 100; // Унаследовано от Vehicle
        car.drive();     // Унаследовано от Vehicle
        car.honk();      // Собственный метод класса Car
    }
}

```

### 12. Опишите процесс создания нового объекта.

Процесс создания нового объекта в Java включает несколько шагов:

- Загрузка класса. Когда в коде встречается создание объекта, Java загружает соответствующий класс (если он ещё не загружен). Класс может быть загружен с использованием файлов .class или динамически загружен во время выполнения с помощью класса ClassLoader

- Выделение памяти. Для нового объекта в памяти выделяется область, достаточная для хранения всех его полей. Это делается в куче (heap) - области памяти, где размещаются объекты

- Инициализация полей по умолчанию. Все поля объекта инициализируются значениями по умолчанию. Примитивные типы данных (int, boolean и так далее) получают соответствующие начальные значения (например, `0` для `int` или `false` для `boolean`), а ссылочные типы (например, другие объекты) получают значение `null`

- Вызов конструктора. Конструктор - это специальный метод, который инициализирует объект с конкретными значениями. Он вызывается после выделения памяти и присваивания значений по умолчанию. Если конструктор требует параметров, их значения передаются в конструктор. В конструкторе можно установить значения полей и выполнить другие действия для настройки объекта.

- Возвращение ссылки на объект. После завершения вызова конструктора объект считается полностью созданным, и переменной, через которую объект создаётся, присваивается ссылка на этот объект. Эта ссылка позволяет взаимодействовать с объектом через его методы и поля.

Пример создания объекта в Java:

```java
class Car {
    String brand;
    int speed;
    
    // Конструктор класса
    public Car(String brand, int speed) {
        this.brand = brand;
        this.speed = speed;
    }
}

public class Main {
    public static void main(String[] args) {
        // Создание объекта типа Car
        Car car = new Car("Toyota", 120);
    }
}
```

Этапы создания объекта `Car`:

- Загрузка класса `Car` (если он ещё не загружен)
- Выделение памяти для объекта `car`
- Инициализация полей по умолчанию - поле `brand` и `speed` инициализируются значениями `null` и `0` соответственно
- Вызов конструктора - `new Car("Toyota", 120)` передаёт значения `"Toyota"` и `120` в конструктор, которые присваиваются полям `brand` и `speed`
- Возвращение ссылки - ссылка на созданный объект присваивается переменной `car`

### 13. Как вызвать метод из родительского класса?

Чтобы вызвать метод из родительского класса в Java, нужно использовать ключевое слово `super`. Это позволяет обращаться к методам и конструкторам родительского класса, расширяя и изменяя функциональность класса, но сохраняя при этом наследуемые свойства и методы.

Ключевое слово `super` используется только для вызова методов и конструкторов родительского класса. Можно вызвать только те методы родительского класса, которые не являются `private`. Если метод родителя был объявлен как `private`, он не доступен в дочернем классе. Вызов конструктора родителя `super()` должен быть первой строкой в конструкторе дочернего класса, если он используется.

Эти возможности позволяют вам расширять и изменять функциональность класса, сохраняя при этом наследуемые свойства и методы.

- Вызов метода родительского класса из метода дочернего класса: если метод в дочернем классе переопределяет метод родительского класса, но нужно вызвать реализацию родительского метода, используя `super`. Пример кода и вывод:

```java
class Parent {
    void display() {
        System.out.println("Method from Parent");
    }
}

class Child extends Parent {
    @Override
    void display() {
        // Вызов метода родительского класса
        super.display();
        System.out.println("Method from Child");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.display();
    }
}
```

```java
Method from Parent
Method from Child
```

- Вызов конструктора родительского класса из конструктора дочернего класса: если нужно вызвать конструктор родительского класса, то необходимо использовать `super()` в конструкторе дочернего класса. Пример кода и вывод:

```java
class Parent {
    Parent() {
        System.out.println("Parent constructor");
    }
}

class Child extends Parent {
    Child() {
        // Вызов конструктора родительского класса
        super();
        System.out.println("Child constructor");
    }
}

public class Main {
    public static void main(String[] args) {
        new Child();
    }
}
```

```java
Parent constructor
Child constructor
```

### 14. Что такое переопределение метода?

Переопределение метода (или overriding) - это механизм в ООП, который позволяет классу предоставить свою реализацию метода, уже существующего в его родительском классе. При этом метод в подклассе должен иметь такое же имя, параметры и тип возвращаемого значения, как и в родительском классе. Цель переопределения - изменить поведение унаследованного метода для подкласса.

Пример:

```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.sound(); // Выведет "Dog barks"
    }
}
```

В этом примере метод `sound` был переопределен в классе `Dog`, чтобы изменить поведение метода, унаследованного от класса `Animal`.

В примере выше можно вызвать непереопределённый метод родительского класса Animal внутри класса Dog, используя ключевое слово super. Это позволит вызвать версию метода из родительского класса.

Пример кода и вывода:

```java
class Animal {
    public void sound() {
        System.out.println("Animal makes a sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        // Вызов метода родительского класса
        super.sound();
        // Дополнительное поведение
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.sound();
    }
}
```

```java
Animal makes a sound
Dog barks
```

Здесь при вызове метода `sound()` у объекта `Dog`, сначала вызывается метод `sound()` родительского класса `Animal` через `super.sound()`, а затем добавляется новое поведение (`"Dog barks"`).

Переопределение требуется в случае, когда нужно изменить поведение в дочернем классе или добавить в него новые возможности. Также переопределение необходимо в случае использования полиморфизма, когда разные классы могут иметь одинаковые методы, но выполняют их по-разному, что помогает создавать гибкий код. Так, вызывая метод sound() для объектов типа Animal, программа выполнит метод, соответствующий конкретному типу объекта (например, Dog или Cat). Важно: если в родительском классе определен абстрактный метод (без реализации), дочерний класс обязан его переопределить и предоставить реализацию.

Пример переопределения абстрактного класса:

```java
abstract class Animal {
  public abstract void sound();
}

class Dog extends Animal {
  @Override
  public void sound() {
    System.out.println("Dog barks");
  }
}
```

### 15. Можно ли переопределить статический метод?

Кратко: нет, статические методы в Java нельзя переопределить, так как они не участвуют в полиморфизме. Статические методы можно только сокрыть. Вызов статических методов основывается на типе ссылки, а не на фактическом типе объекта, что отличает их от обычных методов.

Статические методы привязаны к классу, а не к объекту. Когда вы вызываете статический метод, он вызывается на уровне класса, а не экземпляра. Переопределение (override) же относится к объектно-ориентированному полиморфизму, который работает только с экземплярами классов. Иначе - статические методы вызываются на уровне класса, а не через объекты, что исключает возможность их полиморфного поведения. Для вызова статических методов не требуется создавать объект, и при вызове такого метода компилятор определяет, какой именно метод вызвать, на этапе компиляции (что называется ранним связыванием).

Дополнительно. Полиморфизм - это возможность объектов разных классов по-разному реагировать на вызовы методов, которые определены в их родительском классе. Поскольку статические методы не могут участвовать в полиморфизме, их нельзя переопределять. Вместо этого статические методы можно скрыть (shadowing) в дочернем классе.

### 16. Что такое сокрытие метода?

Сокрытие метода (method hiding) - объявление статического метода в дочернем классе с тем же именем и сигнатурой, что и в родительском. В этом случае статический метод дочернего класса скрывает метод родительского класса.

Пример сокрытия:

```java
class Parent {
  public static void staticMethod() {
    System.out.println("Static method in Parent");
  }
}

class Child extends Parent {
  public static void staticMethod() {
    System.out.println("Static method in Child");
  }
}

public class Test {
  public static void main(String[] args) {
    Parent.staticMethod(); // Вызовет метод из Parent: "Static method in Parent"
    Child.staticMethod();  // Вызовет метод из Child: "Static method in Child"

    Parent obj = new Child();
    obj.staticMethod(); // Все равно вызовет метод из Parent, а не из Child
  }
}
```

В этом примере, несмотря на создание объекта типа `Child`, вызов статического метода будет связан с классом `Parent`, поскольку статические методы не участвуют в полиморфизме.

### 17. Что такое виртуальная функция и используются ли они в Java?

### 18. Что такое перегрузка метода?

Перегрузка метода (Method Overloading) - это возможность создания нескольких методов с одинаковым именем, но разными параметрами в одном классе. Методы с одинаковыми именами должны отличаться по количеству параметров, типу параметров, последовательности типов параметров. Возвращаемый тип метода не влияет на возможность перегрузки. Перегрузка позволяет использовать один и тот же метод для разных типов или количества входных данных, повышая гибкость кода. JVM выбирает метод для вызова на основе типов и количества переданных аргументов.

Пример перегрузки метода:

```java
class Calculator {

    // Метод для сложения двух целых чисел
    public int add(int a, int b) {
        return a + b;
    }

    // Метод для сложения трёх целых чисел
    public int add(int a, int b, int c) {
        return a + b + c;
    }

    // Метод для сложения двух чисел с плавающей точкой
    public double add(double a, double b) {
        return a + b;
    }
}

public class Test {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        // Вызов метода для целых чисел
        System.out.println(calc.add(2, 3));       // Вывод: 5
        
        // Вызов перегруженного метода с тремя параметрами
        System.out.println(calc.add(2, 3, 4));    // Вывод: 9
        
        // Вызов перегруженного метода для чисел с плавающей точкой
        System.out.println(calc.add(2.5, 3.5));   // Вывод: 6.0
    }
}
```
Пример, когда перегрузка невозможна:

```java
class Example {
    public int method(int a) {
        return a;
    }

    // Ошибка! Перегруженный метод не может различаться только по возвращаемому типу.
    public double method(int a) {
        return a;
    }
}
```

Здесь компилятор не сможет различить два метода, так как они имеют одинаковые параметры, несмотря на разный тип возвращаемого значения.

### 19. Можно ли изменить тип возвращаемых данных при перегрузке метода?

Да, при перегрузке метода можно изменить тип возвращаемых данных, но это возможно только в сочетании с изменением параметров метода (количества, типов или их порядка). Перегрузка основывается на различиях в сигнатурах методов (совокупность имени метода и типов параметров). Однако одна только разница в типе возвращаемого значения не может служить основанием для перегрузки метода.

### 20. Что такое множественное наследование? Как его можно реализовать в Java.

Множественное наследование - это механизм в ООП, который позволяет классу наследовать поведение (методы) и данные (свойства) от нескольких родительских классов. Этот подход поддерживается, например, в C++. Однако в Java множественное наследование классов запрещено для того, чтобы избежать сложностей и неоднозначностей, таких как "ромбовидная проблема". Это ограничение означает, что в Java класс может наследоваться только от одного родительского класса. В Java можно частично реализовать множественное наследование через интерфейсы. Класс может реализовывать несколько интерфейсов, что позволяет ему использовать множественные контракты без наследования конкретной реализации.

Пример множественного наследования через интерфейсы:

```java
// Первый интерфейс
interface Flyable {
    void fly();
}

// Второй интерфейс
interface Swimmable {
    void swim();
}

// Класс, реализующий оба интерфейса
class Duck implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("Duck is flying");
    }

    @Override
    public void swim() {
        System.out.println("Duck is swimming");
    }
}

public class Main {
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.fly();
        duck.swim();
    }
}
```

Здесь класс `Duck` реализует два интерфейса (`Flyable` и `Swimmable`), что позволяет ему иметь поведение обоих, как если бы он наследовал от двух разных классов.

Особенности. Интерфейсы в Java могут иметь дефолтные методы с реализацией. Если класс реализует два интерфейса с одинаковыми методами, нужно явно указать, какую реализацию использовать. Это позволяет избежать проблем множественного наследования и сохранить простоту и безопасность кода.

Пример с обычным и дефолтным методами:

```java
interface Animal {
  void sound();  // обычный метод

  default void eat() {  // дефолтный метод
    System.out.println("The animal is eating");
  }
}

class Dog implements Animal {
  @Override
  public void sound() {
    System.out.println("Dog barks");
  }

  // можно использовать дефолтный метод eat(), но можно и переопределить его
}

public class Main {
  public static void main(String[] args) {
    Dog dog = new Dog();
    dog.sound();  // "Dog barks"
    dog.eat();    // "The animal is eating" (использует дефолтную реализацию)
  }
}
```

Пример с указанием конкретной реализации интерфейса:

```java
interface A {
  default void print() {
    System.out.println("Interface A");
  }
}

interface B {
  default void print() {
    System.out.println("Interface B");
  }
}

class MyClass implements A, B {
  @Override
  public void print() {
    // Явное указание, какой метод использовать
    A.super.print();  // Вызов метода из интерфейса A
    // B.super.print();  // Можно выбрать метод из B, если требуется
  }
}

public class Main {
  public static void main(String[] args) {
    MyClass myClass = new MyClass();
    myClass.print();  // Выведет: "Interface A"
  }
}
```

### 21. Что такое полиморфизм? Приведите примеры из реальной жизни.

Полиморфизм - это концепция в ООП, которая позволяет объектам разных классов обрабатывать вызовы одноимённых методов по-разному. Он позволяет использовать один и тот же интерфейс для разных типов объектов. В Java полиморфизм реализуется через наследование и интерфейсы.

Примеры из реальной жизни:

- кнопка лифта (когда человек нажимает кнопку на панели лифта, кнопка может вызывать разные действия в зависимости от ситуации, если лифт находится на текущем этаже, он не будет двигаться, если лифт на другом этаже, он начнет двигаться в нужном направлении, в терминах ООП, класс кнопки лифта имеет метод `нажать()`, и разные классы (например, лифт на этаже и лифт на другом этаже) реализуют этот метод по-разному)

- форма оплаты (касса, которая принимает разные способы оплаты - наличные, карту, мобильные платежи, у кассы есть метод `оплатить()`, но в зависимости от типа платежа (картой или наличными) выполняются разные действия, в этом случае каждый тип оплаты может быть отдельным классом, но все они реализуют один интерфейс с методом `оплатить()`)

Пример полиморфизма:

```java
class Animal {
    public void sound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    public void sound() {
        System.out.println("Bark");
    }
}

class Cat extends Animal {
    @Override
    public void sound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();  // Полиморфизм
        Animal myCat = new Cat();  // Полиморфизм
        
        myDog.sound();  // Выведет: "Bark"
        myCat.sound();  // Выведет: "Meow"
    }
}
```

В примере переменные `myDog` и `myCat` имеют тип `Animal`, но в зависимости от того, к какому классу они принадлежат на самом деле (`Dog` или `Cat`), они вызывают свои собственные версии метода `sound()`. Это и есть полиморфизм. Таким образом, полиморфизм позволяет вам писать более гибкий и модульный код, где один и тот же интерфейс может обрабатывать объекты разных типов по-разному.

### 22. Что такое инкапсуляция?

Инкапсуляция - это одна из ключевых концепций ООП, которая заключается в сокрытии внутренней реализации объекта и предоставлении доступа к его данным и поведению только через публичные методы (геттеры и сеттеры). Основная идея инкапсуляции - защитить данные объекта от прямого внешнего вмешательства и некорректного использования.

Основные принципы инкапсуляции:

- Скрытие данных (полей). Внутренние данные объекта (переменные, поля) должны быть скрыты и недоступны извне напрямую. Для этого поля объекта часто объявляются с модификатором доступа `private`

- Доступ через методы. Для доступа к скрытым данным объект предоставляет публичные методы - геттеры (для получения значений) и сеттеры (для изменения значений). Эти методы позволяют контролировать, как изменяются и читаются данные

Пример инкапсуляции в Java:

```java
public class Person {
    private String name;  // Приватное поле, недоступное напрямую извне
    private int age;      // Приватное поле

    // Публичный геттер для получения имени
    public String getName() {
        return name;
    }

    // Публичный сеттер для установки имени
    public void setName(String name) {
        this.name = name;
    }

    // Публичный геттер для получения возраста
    public int getAge() {
        return age;
    }

    // Публичный сеттер для установки возраста с проверкой
    public void setAge(int age) {
        if (age > 0) { // Проверка валидности данных
            this.age = age;
        } else {
            System.out.println("Age cannot be negative or zero");
        }
    }
}
```

Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        Person person = new Person();
        person.setName("Alice");    // Изменение имени через сеттер
        person.setAge(25);          // Установка возраста через сеттер

        System.out.println("Name: " + person.getName()); // Получение имени через геттер
        System.out.println("Age: " + person.getAge());   // Получение возраста через геттер
    }
}
```

Преимущества инкапсуляции:

- Защита данных: поля объекта защищены от случайных или некорректных изменений извне
- Контроль доступа: сеттеры могут включать логику проверки данных перед их изменением
- Изменяемость: можно изменить внутреннюю реализацию объекта, не нарушая интерфейс для других классов, использующих объект

Таким образом, инкапсуляция делает код более безопасным, контролируемым и гибким.

### 23. Как реализована инкапсуляция в Java?

Инкапсуляция в Java реализована с помощью модификаторов доступа (контролируют доступ к полям и методам класса) и (сокрытия данных с предоставлением доступа через публичные методы - так называемые геттеры и сеттеры). Инкапсуляция помогает защитить данные объекта и контролировать их модификацию.

Модификаторы доступа:

- `private` - поле или метод доступны только внутри класса, в котором они определены
- `public` - поле или метод доступны для всех классов
- `protected` и пакетный доступ (без модификатора) - более гибкие уровни доступа, но для инкапсуляции чаще всего используются `private` и `public`

Пример реализации инкапсуляции в Java:

```java
public class Employee {
    // Приватные поля (сокрытие данных)
    private String name;
    private int salary;

    // Конструктор
    public Employee(String name, int salary) {
        this.name = name;
        setSalary(salary);  // Используем сеттер для установки значения с проверкой
    }

    // Публичный геттер для имени
    public String getName() {
        return name;
    }

    // Публичный сеттер для имени
    public void setName(String name) {
        this.name = name;
    }

    // Публичный геттер для зарплаты
    public int getSalary() {
        return salary;
    }

    // Публичный сеттер для зарплаты с проверкой
    public void setSalary(int salary) {
        if (salary > 0) {
            this.salary = salary;
        } else {
            System.out.println("Salary must be positive");
        }
    }
}
```

Пример использования:

```java
public class Main {
    public static void main(String[] args) {
        Employee emp = new Employee("John", 5000);

        // Получаем и выводим значения через геттеры
        System.out.println("Employee name: " + emp.getName());
        System.out.println("Employee salary: " + emp.getSalary());

        // Изменяем значения через сеттеры
        emp.setName("Jane");
        emp.setSalary(6000);

        System.out.println("Updated employee name: " + emp.getName());
        System.out.println("Updated employee salary: " + emp.getSalary());
    }
}
```

Приватные поля `name` и `salary` скрыты от внешних классов. Они могут быть прочитаны или изменены только через методы. Геттеры и сеттеры обеспечивают безопасный доступ к полям, позволяя, например, проверять корректность данных при их изменении (как в методе `setSalary`).

### 24. Можно ли применить модификаторы доступа к конструкторам?

### 25. Что такое интерфейс?

### 26. Перечислите элементы, которые может содержать интерфейс.

### 27. Можно ли создать объект интерфейса? Если да, то как?

### 28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?

### 29. Что такое абстракция?

### 30. Что такое абстрактный класс?

### 31. Сколько абстрактных методов должен и может содержать абстрактный класс?

### 32. Может ли абстрактный класс содержать обычные методы?

### 33. Сколько объектов абстрактного класса можно создать в программе?

### 34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?

### 35. Чем отличается интерфейс от абстрактного класса?

### 36. Что такое вложенные классы? Зачем они нужны?

### 37. Какие типы вложенных классов существуют в Java?

### 38. Что такое внутренний класс? Когда он применяется?

### 39. Что такое статический вложенный класс? Когда он применяется?

### 40. Сколько объектов статического вложенного класса можно создать в программе?

### 41. Что такое локальный класс? Когда он применяется?

### 42. Что такое анонимный класс? Когда он применяется?

### 43. Сколько объектов анонимного класса можно создать в программе?

### 44. Что такое исключения? Какие типы исключительных ситуаций бывают?

### 45. Назовите основные методы класса Object?

Класс `Object` предоставляет несколько важных методов, которые могут быть переопределены в наследуемых классах:

- `toString()` возвращает строковое представление объекта
- `equals(Object obj)` сравнивает два объекта на равенство
- `hashCode()` возвращает хеш-код объекта
- `getClass()` возвращает объект класса `Class`, который представляет класс объекта
- `clone()` создает и возвращает копию объекта (если класс реализует интерфейс `Cloneable`)
- `finalize()` выполняет очистку перед сборкой мусора (редко используется)

### 46. Что такое шаблоны проектирования?

Шаблоны проектирования (design patterns) - это готовые решения для часто встречающихся проблем в проектировании программного обеспечения. Они помогают строить гибкую, поддерживаемую и легко изменяемую архитектуру кода. Шаблоны не являются готовым кодом, это скорее инструкции по реализации определенных архитектурных решений.

Шаблоны делятся на три основные категории:

- порождающие - управляют созданием объектов (например, Singleton, Factory Method)
- структурные - описывают, как классы и объекты могут быть объединены для создания более крупных структур (например, Adapter, Decorator)
- поведенческие - определяют способы взаимодействия между объектами и их обязанности (например, Observer, Strategy)

### 47. Объясните шаблон "декоратор". Придумайте пример, не относящийся к технике.

Шаблон "Декоратор" (Decorator) позволяет динамически добавлять новые функциональные возможности объекту, не изменяя его структуры. Он оборачивает объект в новый класс, добавляющий поведение, сохраняя интерфейс исходного объекта.

Пример (не связанный с техникой). Представьте базовый класс `Торт`, который имеет метод `приготовить()`. Мы можем "декорировать" его, добавляя разные слои, например, `ШоколадныйДекор` или `ФруктовыйДекор`, которые добавляют украшения, сохраняя основную функцию торта. Каждый декоратор добавляет свой слой, не изменяя сам торт.

### 48. Объясните шаблон "стратегия". Придумайте пример, не относящийся к технике.

Шаблон "Стратегия" (Strategy) позволяет выбирать алгоритм поведения на основе ситуации во время выполнения программы. Шаблон разделяет алгоритмы в отдельные классы и позволяет объектам использовать их взаимозаменяемо.

Пример (не связанный с техникой). Представьте человека, который решает, как передвигаться в зависимости от погоды. Если на улице дождь - он выбирает такси, если погода хорошая - идёт пешком, а если спешит - выбирает велосипед. Все эти способы - разные стратегии передвижения, которые человек может выбрать, исходя из условий.

### 49. Объясните шаблон "синглтон". Придумайте пример, не относящийся к технике.

Шаблон "синглтон" (Singleton) гарантирует, что класс имеет только один экземпляр, и предоставляет глобальную точку доступа к этому экземпляру.

Пример (не связанный с техникой). Представьте, что в городе есть один мэр. Неважно, сколько бы человек не пытались стать мэром, всегда будет только один действующий мэр на данный момент. Этот мэр управляет городом, и все обращения направляются к нему. В этом примере мэр - это "синглтон", потому что существует только один активный мэр в одно время.

### 50. Объясните шаблон "фабричный метод". Придумайте пример, не относящийся к технике.

Шаблон "фабричный метод" (Factory Method) - это порождающий шаблон проектирования, который предоставляет интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемого объекта.

Пример (не связанный с техникой). Представьте себе кондитерскую фабрику, которая делает пирожные. В зависимости от того, какой праздник предстоит (День рождения, Новый год, свадьба), фабрика производит разные типы пирожных: праздничные, новогодние, свадебные. Заказчик просто выбирает тип праздника, а фабрика сама решает, какие пирожные приготовить.

### 51. Что такое enum? Когда можно его применять?

### 52. Что такое record? Когда можно его применять?

### 53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?

`StringBuilder`, `StringBuffer` и `StringJoiner` - это классы в Java, которые помогают работать с изменяемыми строками. Они позволяют эффективно манипулировать текстом, что делает их полезными в сценариях, когда строка изменяется (например, при конкатенации). Классы `StringBuilder` и `StringBuffer` используются для эффективного построения строк в циклах, а класс `StringJoiner` удобен для создания строк с разделителями между элементами, как в списках или коллекциях.

- `StringBuilder`:

    - Используется для создания и изменения строк
    - Позволяет изменять строку без создания нового объекта на каждой итерации
    - Основное отличие от `String` в том, что объекты `StringBuilder` изменяемы, а объекты `String` - нет
    - Преимущество: быстрее, чем `String`, при частой модификации строк (например, в цикле)
    - Недостаток: не синхронизирован, то есть не потокобезопасен

- `StringBuffer`:

    - Аналогичен `StringBuilder`, но с синхронизацией
    - Используется для многопоточных программ, где несколько потоков могут изменять строку одновременно.
    - Преимущество: потокобезопасен
    - Недостаток: медленнее, чем `StringBuilder`, из-за дополнительной синхронизации

- `StringJoiner`:

    - Используется для создания строки из отдельных элементов с добавлением разделителя (например, запятой)
    - Очень удобен для формирования строк, где нужно объединить несколько частей с разделителями, например, список имён или URL-параметров
    - Преимущество: специализирован для операций соединения строк с разделителями и более удобен, чем ручная конкатенация с использованием циклов

Эффективная конкатенация строк в цикле при помощи `StringBuilder`:

```java
public class StringBuilderExample {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 5; i++) {
            sb.append("Element ").append(i).append(" ");
        }
        System.out.println(sb.toString());
    }
}
```

Эффективная конкатенация строк в цикле (потокобезопасный вариант) при помощи `StringBuffer`:

```java
public class StringBufferExample {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < 5; i++) {
            sb.append("Element ").append(i).append(" ");
        }
        System.out.println(sb.toString());
    }
}
```

Объединение элементов коллекции в строку с заданным разделителем при помощи `StringJoiner`:

```java
import java.util.StringJoiner;

public class StringJoinerExample {
    public static void main(String[] args) {
        StringJoiner sj = new StringJoiner(", ");
        sj.add("Apple");
        sj.add("Banana");
        sj.add("Orange");
        
        System.out.println(sj.toString());  // Output: Apple, Banana, Orange
    }
}
```

### 54. Чем отличаются StringBuffer и StringBuilder?

Классы `StringBuilder` и `StringBuffer` используются для эффективного построения строк в циклах. Класс `StringBuilder` быстрее и легче, чем `StringBuffer`, но, в отличие от него, не потокобезопасен.

### 55. Каким образом производится экранирование символов и зачем это нужно?

### 56. Что такое управляющие последовательности?

### 57. Зачем нужно форматирование данных? Метод format()

### 58. Что такое varargs? В каких случаях стоит его применять?

### 59. В каких случаях может возникнуть неоднозначность при работе с varargs?

### 60. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?